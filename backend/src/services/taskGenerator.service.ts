import Task from "../models/Task";
import { IExtractedData } from "../models/ExtractedData";
import mongoose from "mongoose";

interface TaskGenerationOptions {
  contractId: mongoose.Types.ObjectId;
  organizationId: mongoose.Types.ObjectId;
  createdBy: mongoose.Types.ObjectId;
  extractedData: IExtractedData;
}

class TaskGeneratorService {
  /**
   * Auto-generate tasks from extracted contract dates
   */
  async generateTasksFromExtractedData(
    options: TaskGenerationOptions
  ): Promise<any[]> {
    const { contractId, organizationId, createdBy, extractedData } = options;
    const tasksToCreate: any[] = [];

    // Check if tasks already exist for this contract
    const existingTasks = await Task.countDocuments({
      contractId,
      autoGenerated: true,
    });

    if (existingTasks > 0) {
      console.log(
        `⚠️ Tasks already exist for contract ${contractId}, skipping auto-generation`
      );
      return [];
    }

    // Generate renewal task
    if (extractedData.renewalDate?.value) {
      const renewalDate = new Date(extractedData.renewalDate.value);
      
      // Create task 30 days before renewal
      const taskDate = new Date(renewalDate);
      taskDate.setDate(taskDate.getDate() - 30);

      // Only create if in the future
      if (taskDate > new Date()) {
        tasksToCreate.push({
          contractId,
          organizationId,
          type: "renewal",
          title: "Contract Renewal Due",
          description: `Contract renewal date is ${renewalDate.toLocaleDateString()}. Review and prepare renewal documentation.`,
          dueDate: taskDate,
          priority: "high",
          status: "pending",
          autoGenerated: true,
          createdBy,
        });
      }
    }

    // Generate termination task
    if (extractedData.terminationDate?.value) {
      const terminationDate = new Date(extractedData.terminationDate.value);
      
      // Create task 60 days before termination
      const taskDate = new Date(terminationDate);
      taskDate.setDate(taskDate.getDate() - 60);

      // Only create if in the future
      if (taskDate > new Date()) {
        tasksToCreate.push({
          contractId,
          organizationId,
          type: "termination",
          title: "Contract Termination Approaching",
          description: `Contract termination date is ${terminationDate.toLocaleDateString()}. Review termination clauses and prepare accordingly.`,
          dueDate: taskDate,
          priority: "medium",
          status: "pending",
          autoGenerated: true,
          createdBy,
        });
      }
    }

    // Generate notice period task if termination date exists
    if (extractedData.terminationDate?.value) {
      const terminationDate = new Date(extractedData.terminationDate.value);
      
      // Create notice task 90 days before termination (typical notice period)
      const taskDate = new Date(terminationDate);
      taskDate.setDate(taskDate.getDate() - 90);

      // Only create if in the future
      if (taskDate > new Date()) {
        tasksToCreate.push({
          contractId,
          organizationId,
          type: "notice",
          title: "Notice Period Deadline",
          description: `If terminating, notice must be given by ${taskDate.toLocaleDateString()}. Termination date: ${terminationDate.toLocaleDateString()}.`,
          dueDate: taskDate,
          priority: "high",
          status: "pending",
          autoGenerated: true,
          createdBy,
        });
      }
    }

    // Scan clauses for obligations with dates
    if (extractedData.clauses && Array.isArray(extractedData.clauses)) {
      const obligationKeywords = [
        "must",
        "shall",
        "required",
        "obligation",
        "deliver",
        "provide",
        "submit",
        "report",
      ];

      for (const clause of extractedData.clauses) {
        const content = clause.content?.toLowerCase() || "";
        const hasObligation = obligationKeywords.some((keyword) =>
          content.includes(keyword)
        );

        if (hasObligation) {
          // Try to extract dates from clause content
          const dateMatch = content.match(
            /(\d{1,2}[-\/]\d{1,2}[-\/]\d{2,4})|(\d{1,2}\s+(jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec)\w*\s+\d{2,4})/i
          );

          if (dateMatch) {
            try {
              const obligationDate = new Date(dateMatch[0]);
              if (
                obligationDate > new Date() &&
                obligationDate.getFullYear() > 2000
              ) {
                tasksToCreate.push({
                  contractId,
                  organizationId,
                  type: "obligation",
                  title: `Obligation: ${clause.clauseType || "Contract Clause"}`,
                  description: clause.content?.substring(0, 200) || "",
                  dueDate: obligationDate,
                  priority: "medium",
                  status: "pending",
                  autoGenerated: true,
                  createdBy,
                });
              }
            } catch (error) {
              // Skip if date parsing fails
            }
          }
        }
      }
    }

    // Bulk create tasks
    if (tasksToCreate.length > 0) {
      const createdTasks = await Task.insertMany(tasksToCreate);
      console.log(
        `✅ Auto-generated ${createdTasks.length} tasks for contract ${contractId}`
      );
      return createdTasks;
    }

    return [];
  }

  /**
   * Calculate priority based on due date proximity
   */
  calculatePriority(dueDate: Date): "low" | "medium" | "high" | "critical" {
    const now = new Date();
    const daysUntilDue = Math.ceil(
      (dueDate.getTime() - now.getTime()) / (1000 * 60 * 60 * 24)
    );

    if (daysUntilDue < 0) return "critical"; // Overdue
    if (daysUntilDue <= 7) return "critical";
    if (daysUntilDue <= 30) return "high";
    if (daysUntilDue <= 90) return "medium";
    return "low";
  }
}

export default new TaskGeneratorService();

